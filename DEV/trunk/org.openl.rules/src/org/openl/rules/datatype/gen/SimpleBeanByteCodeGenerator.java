package org.openl.rules.datatype.gen;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import net.sf.cglib.core.ReflectUtils;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.objectweb.asm.ClassWriter;
import org.openl.rules.datatype.gen.bean.writers.BeanByteCodeWriter;
import org.openl.rules.datatype.gen.bean.writers.ClassDescriptionWriter;
import org.openl.rules.datatype.gen.bean.writers.ConstructorWithParametersWriter;
import org.openl.rules.datatype.gen.bean.writers.DefaultConstructorWriter;
import org.openl.rules.datatype.gen.bean.writers.EqualsWriter;
import org.openl.rules.datatype.gen.bean.writers.GettersAndSettersWriter;
import org.openl.rules.datatype.gen.bean.writers.HashCodeWriter;
import org.openl.rules.datatype.gen.bean.writers.PrivateFieldsWriter;
import org.openl.rules.datatype.gen.bean.writers.ToStringWriter;
import org.openl.util.generation.JavaClassGeneratorHelper;

/**
 * Generates byte code for simple java bean.
 * 
 * @author DLiauchuk
 *
 */
public class SimpleBeanByteCodeGenerator {

    private final Log LOG = LogFactory.getLog(SimpleBeanByteCodeGenerator.class);
    
    private String beanName;
    private Class<?> parentClass;
    private LinkedHashMap<String, FieldDescription> beanFields;
    private LinkedHashMap<String, FieldDescription> parentFields;
    private LinkedHashMap<String, FieldDescription> allFields;    
   
    private byte[] generatedByteCode;

    private String beanNameWithPackage;
    
    /**
     * list of writers to generate necessary byte code class representation.
     */
    private List<BeanByteCodeWriter> writers = new ArrayList<BeanByteCodeWriter>();

    /**
     * 
     * @param beanName name of the generated class, with namespace (e.g. <code>my.test.TestClass</code>)
     * @param beanFields map of fields, field name as a key, and type as value.
     */
    public SimpleBeanByteCodeGenerator(String beanName, Map<String, FieldDescription> beanFields) {
        this(beanName, beanFields, null, new LinkedHashMap<String, FieldDescription>());
    }

    /**
     * 
     * @param beanName name of the generated class, with namespace (e.g.
     *            <code>my.test.TestClass</code>)
     * @param beanFields map of fields, field name as a key, and type as value.
     * @param parentClass parent class
     */
    public SimpleBeanByteCodeGenerator(String beanName, Map<String, FieldDescription> beanFields, Class<?> parentClass, 
            Map<String, FieldDescription> parentFields) {
        this.beanName = beanName;
        this.beanNameWithPackage = JavaClassGeneratorHelper.replaceCommas(beanName);
        this.beanFields = new LinkedHashMap<String, FieldDescription>(beanFields);
        this.parentFields = new LinkedHashMap<String, FieldDescription>(parentFields);
        this.parentClass = parentClass;
        
        allFields = new LinkedHashMap<String, FieldDescription>();
        allFields.putAll(parentFields);
        allFields.putAll(beanFields); 
        
        initWriters();
    }

    private void initWriters() {
        writers.add(new ClassDescriptionWriter(beanNameWithPackage, parentClass));
        writers.add(new PrivateFieldsWriter(beanFields));
        writers.add(new DefaultConstructorWriter(beanNameWithPackage, parentClass, beanFields));
        writers.add(new ConstructorWithParametersWriter(beanNameWithPackage, parentClass, beanFields, parentFields, allFields));
        writers.add(new GettersAndSettersWriter(beanNameWithPackage, beanFields));
        writers.add(new ToStringWriter(beanNameWithPackage, allFields));
        writers.add(new EqualsWriter(beanNameWithPackage, allFields));
        writers.add(new HashCodeWriter(beanNameWithPackage, allFields));
    }

    /**
     *  
     * @return generated byte code of the simple bean
     */
    public byte[] generateClassByteCode() {
        ClassWriter classWriter = new ClassWriter(false);
        
        for (BeanByteCodeWriter writer : writers) {
            writer.write(classWriter);
        }        
        
        generatedByteCode = classWriter.toByteArray();
        
//        writeBytesToFile(generatedByteCode);
        
        return generatedByteCode;
    }
    
    /**
     * 
     * @return <code>Class<?></code> object of the generated bean class.
     */
    public Class<?> generateAndLoadBeanClass() {
        if (generatedByteCode != null) {
            return loadClass(generatedByteCode);
        } else {
            return loadClass(generateClassByteCode());
        }
    }

    @SuppressWarnings("unused")
    private void writeBytesToFile(byte[] byteArray) {
        String strFilePath = String.format("D://%s.class", JavaClassGeneratorHelper.getShortClassName(beanName));
        try {
            FileOutputStream fos = new FileOutputStream(strFilePath);
            fos.write(byteArray);
            fos.close();
        } catch(FileNotFoundException ex) {
            LOG.error(this, ex);
        } catch(IOException ioe){
            LOG.error(this, ioe);
        }
    }
    
    private boolean isClassLoaderContainsClass(ClassLoader classLoader, String className){
        try {
            return classLoader.loadClass(className) != null;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }
    
    /**
     * Return loaded to classpath class object
     * 
     * @param byteCode generated byteCode
     * 
     * @return <code>Class<?></code> descriptor for given byteCode
     */
    private Class<?> loadClass(byte[] byteCode) {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        try {
            // try to define bean class in classloader, and return
            // class object.
            if (isClassLoaderContainsClass(classLoader, beanName)) {
                return classLoader.loadClass(beanName);
            } else {
                return ReflectUtils.defineClass(beanName, byteCode, classLoader);
            }
        } catch (Exception ex) {
            LOG.debug(this, ex);
            try {
                // if defining fails, when this class already exists in
                // classloader,
                // try to return class object previosly loaded.
                return Class.forName(beanName, true, classLoader);
            } catch (Exception e) {
                LOG.error(this, e);
            } catch (VerifyError exc) {
                LOG.error(this, exc);
            }
        }

        return null;
    }

    public String toString() {
        if (StringUtils.isNotBlank(beanName)) {
            return String.format("Bean with name: %s", beanName);
        } 
        return super.toString();
    }
}
