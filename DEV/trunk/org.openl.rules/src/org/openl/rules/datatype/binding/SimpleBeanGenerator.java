package org.openl.rules.datatype.binding;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import net.sf.cglib.core.ReflectUtils;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.CodeVisitor;
import org.objectweb.asm.Constants;
import org.objectweb.asm.Type;
import org.openl.syntax.impl.ISyntaxConstants;
import org.openl.util.StringTool;

public class SimpleBeanGenerator {
    
    private static final String JAVA_LANG_OBJECT = "java/lang/Object";

    private final Log LOG = LogFactory.getLog(SimpleBeanGenerator.class);
    
    private String beanName;
    private Map<String, FieldType> beanFields;
    private byte[] generatedByteCode;
    
    /**
     * 
     * @param beanName name of the generated class, with namespace (e.g. <code>my.test.TestClass</code>)
     * @param beanFields map of fields, field name as a key, and type as value.
     */
    public SimpleBeanGenerator(String beanName, Map<String, FieldType> beanFields) {
        this.beanName = beanName;
        this.beanFields = new HashMap<String, FieldType>(beanFields);
    }
    
    /**
     *  
     * @return generated byte code of the simple bean
     */
    public byte[] generateClassByteCode() {
        String beanNameWithPackage = replaceCommas(beanName);
        
        ClassWriter classWriter = new ClassWriter(false);

        writeClassDescription(beanNameWithPackage, classWriter);

        writeFields(classWriter);
        
        writeDefaultConstructor(classWriter);
        
        writeGettersAndSetters(beanNameWithPackage, classWriter);
        
        generatedByteCode = classWriter.toByteArray();
        
        //writeBytesToFile(generatedByteCode);
        
        return generatedByteCode;
    }
    
    /**
     * 
     * @return <code>Class<?></code> object of the generated bean class.
     */
    public Class<?> generateAndLoadBeanClass() {
        if (generatedByteCode != null) {
            return loadClass(generatedByteCode);
        } else {
            return loadClass(generateClassByteCode());
        }
    }
    
    /**
     * Writes getters and setters to the generated bean class.
     * 
     * @param beanNameWithPackage
     * @param classWriter
     */
    private void writeGettersAndSetters(String beanNameWithPackage, ClassWriter classWriter) {
        for(Map.Entry<String, FieldType> field : beanFields.entrySet()) {
            generateGetter(beanNameWithPackage, classWriter, field);
            generateSetter(beanNameWithPackage, classWriter, field);
        }
    }

    private void writeDefaultConstructor(ClassWriter classWriter) {
        CodeVisitor codeVisitor;
        // creates a MethodWriter for the (implicit) constructor
        codeVisitor = classWriter.visitMethod(Constants.ACC_PUBLIC, "<init>", "()V", null, null);
        // pushes the 'this' variable
        codeVisitor.visitVarInsn(Constants.ALOAD, 0);
        // invokes the super class constructor
        codeVisitor.visitMethodInsn(Constants.INVOKESPECIAL, JAVA_LANG_OBJECT, "<init>", "()V");
        codeVisitor.visitInsn(Constants.RETURN);
        // this code uses a maximum of one stack element and one local variable
        codeVisitor.visitMaxs(1, 1);
    }
    
    /**
     * Write fields declarations to the generated bean class.
     * 
     * @param classWriter
     */
    private void writeFields(ClassWriter classWriter) {
        for (Map.Entry<String,  FieldType> field : beanFields.entrySet()) {
          String fieldTypeName = getJavaType(field.getValue());
          classWriter.visitField(Constants.ACC_PRIVATE, field.getKey(), fieldTypeName, null, null);
        }
    }
    
    /**
     * Write the description of generating class.
     * 
     * @param beanNameWithPackage name of the class with package, symbol '/' is used as separator<br> 
     * (e.g. <code>my/test/TestClass</code>) 
     * @param classWriter
     */
    private void writeClassDescription(String beanNameWithPackage, ClassWriter classWriter) {
        String sourceFileName = getClassFileName(beanNameWithPackage);
        classWriter.visit(Constants.V1_5, Constants.ACC_PUBLIC + Constants.ACC_SUPER, beanNameWithPackage, JAVA_LANG_OBJECT, 
            null, sourceFileName);
    }

    private void writeBytesToFile(byte[] byteArray) {
        String strFilePath = String.format("D://%s.class", getClassName(beanName));
        try {
            FileOutputStream fos = new FileOutputStream(strFilePath);
            fos.write(byteArray);
            fos.close();
        } catch(FileNotFoundException ex) {
            LOG.error(this, ex);
        } catch(IOException ioe){
            LOG.error(this, ioe);
        }
    }
    
    /**
     * Generates getter for the field.
     * 
     * @param beanNameWithPackage
     * @param classWriter
     * @param field
     */
    private void generateGetter(String beanNameWithPackage, ClassWriter classWriter, Map.Entry<String, FieldType> field) {
        CodeVisitor codeVisitor;
        String fieldName = field.getKey();
        FieldType fieldType = field.getValue();
        String getterName = StringTool.getGetterName(fieldName);
        
        codeVisitor = classWriter.visitMethod(Constants.ACC_PUBLIC,  getterName, String.format("()%s",
            getJavaType(fieldType)), null, null);
        codeVisitor.visitVarInsn(Constants.ALOAD, 0);
        codeVisitor.visitFieldInsn(Constants.GETFIELD, beanNameWithPackage, fieldName, getJavaType(fieldType));
        codeVisitor.visitInsn(getConstantForReturn(fieldType));
        
        // long and double types are the biggest ones, so they use a maximum of two stack  
        // elements and one local variable for getter method.
        if (long.class.equals(fieldType.getType()) || double.class.equals(fieldType.getType())) {
            codeVisitor.visitMaxs(2, 1);
        } else {
            codeVisitor.visitMaxs(1, 1);
        }
    }
    
    private int getConstantForReturn(FieldType fieldType) {
        Class<?> retClass = fieldType.getType();
        if (retClass != null) {
            return getConstantForReturn(retClass);
        } else {
            return Constants.ARETURN;
        }
    }
    
    /**
     * Returns the constant for return type. Each primitive type has its constant.
     * 
     * @param fieldClass
     * @return
     */
    private int getConstantForReturn(Class<?> fieldClass) {
        if (fieldClass.equals(int.class) || fieldClass.equals(short.class) || fieldClass.equals(boolean.class)
                || fieldClass.equals(char.class) || fieldClass.equals(byte.class)) {
            return Constants.IRETURN;
        } else if (fieldClass.equals(long.class)) {
            return Constants.LRETURN;
        } else if (fieldClass.equals(double.class)) {
            return Constants.DRETURN;
        } else if (fieldClass.equals(float.class)) {
            return Constants.FRETURN;
        } else if (fieldClass instanceof Object) {
            return Constants.ARETURN;
        }
        return 0;
    }
    
    /**
     * Generates setter for the field.
     * 
     * @param beanNameWithPackage
     * @param classWriter
     * @param field
     */
    private void generateSetter(String beanNameWithPackage, ClassWriter classWriter, Map.Entry<String, FieldType> field) {
        CodeVisitor codeVisitor;
        String fieldName = field.getKey();
        FieldType fieldType = field.getValue();        
        String setterName = StringTool.getSetterName(field.getKey());
        
        codeVisitor = classWriter.visitMethod(Constants.ACC_PUBLIC,  setterName, String.format("(%s)V", 
            getJavaType(fieldType)), null, null);
        codeVisitor.visitVarInsn(Constants.ALOAD, 0);
        codeVisitor.visitVarInsn(getConstantForVarInsn(fieldType), 1);
        
        codeVisitor.visitFieldInsn(Constants.PUTFIELD, beanNameWithPackage, fieldName, getJavaType(fieldType));
        codeVisitor.visitInsn(Constants.RETURN);
        
        // long and double types are the biggest ones, so they use a maximum of three stack  
        // elements and three local variables for setter method.
        if (long.class.equals(fieldType.getType()) || double.class.equals(fieldType.getType())) {
            codeVisitor.visitMaxs(3, 3);
        } else {
            codeVisitor.visitMaxs(2, 2);
        }
    }
 
    private int getConstantForVarInsn(FieldType fieldType) {
        Class<?> retClass = fieldType.getType();
        if (retClass != null) {
            return getConstantForVarInsn(retClass);
        } else {
            return Constants.ALOAD;
        }
    }

    private int getConstantForVarInsn(Class<?> fieldClass) {
        if (fieldClass.equals(int.class) || fieldClass.equals(short.class) || fieldClass.equals(boolean.class)
                || fieldClass.equals(char.class) || fieldClass.equals(byte.class)) {
            return Constants.ILOAD;        
        } else if (fieldClass.equals(long.class)) {
            return Constants.LLOAD;
        } else if (fieldClass.equals(double.class)) {
            return Constants.DLOAD;
        } else if (fieldClass.equals(float.class)) {
            return Constants.FLOAD;
        } else if (fieldClass instanceof Object) {
            return Constants.ALOAD;
        }
        return 0;
    }   
    
    /**
     * Return loaded to classpath class object
     * 
     * @param byteCode generated byteCode
     * 
     * @return <code>Class<?></code> descriptor for given byteCode
     */
    private Class<?> loadClass(byte[] byteCode) {
        
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        
        // Return loaded to classpath class object.
        try {
            return Class.forName(beanName, true, classLoader);
        } catch (ClassNotFoundException e) {
            try {
                ReflectUtils.defineClass(beanName, byteCode, classLoader);
                return Class.forName(beanName, true, classLoader);
            } catch (Exception ex) {
                LOG.error(this, ex);
            } catch (VerifyError exc) {
                LOG.error(this, exc);
            }
        }
        return null;
    }
    
    /**
     * 
     * @param name name of the class with package, symbol '/' is used as separator<br> 
     * (e.g. <code>my/test/TestClass</code>)
     * 
     * @return class name without package with <code>.java</code> suffix (e.g. <code>TestClass.java</code>)
     */
    private String getClassFileName(String name) {
        String className = getClassName(name);

        return String.format("%s.java", className);
    }
    
    /**
     * 
     * @param name name of the class with package, symbol '/' is used as separator<br> 
     * (e.g. <code>my/test/TestClass</code>)
     * 
     * @return name of the class file without package (e.g. <code>TestClass</code>)
     */
    private String getClassName(String name) {
        String[] path = name.split("/");
        String className = path[path.length - 1];
        return className;
    }
    
    /**
     * Returns the Java type corresponding to the given class.
     * 
     * @param fieldClass
     * @return the Java type corresponding to the given class.
     */
    private String getJavaType(Class<?> fieldClass) {
        return String.valueOf(Type.getType(fieldClass));
    }
    
    /**
     * Gets Java type corresponding to the given field type.
     * 
     * @param fieldType
     * @return Java type corresponding to the given field type. (e.g. <code>Lmy/test/TestClass;</code>)
     */
    private String getJavaType(FieldType fieldType) {
        Class<?> fieldClass = fieldType.getType();
        if (fieldClass != null) {
            return getJavaType(fieldClass);
        } else {
            return getJavaType(fieldType.getTypeName());
        }
    }
    
    /**
     * Generate the Java type corresponding to the given type name.
     * Support array types.<br> 
     * (e.g. <code>Vehicle[][]</code>)
     * 
     * @param typeName name of the type (e.g. <code>TestClass</code>) 
     * @return Java type corresponding to the given type name. (e.g. <code>Lmy/test/TestClass;</code>)
     */
    private String getJavaType(String typeName) {        
        boolean isArray = StringUtils.contains(typeName, "[");
        if (isArray) {
            return getJavaArrayType(typeName);
        } else {
            String nameWithPackage = getTypeNameWithPackage(typeName);
            return String.format("L%s;", nameWithPackage);
        }
    }
    
    /**
     * Returns the type name with package definition by type name. 
     * 
     * @param typeName (e.g. <code>TestClass</code>)
     * @return e.g. <code>my/test/TestClass</code>
     */
    private String getTypeNameWithPackage(String typeName) {        
        String nameWithNamespace = String.format("%s.%s", ISyntaxConstants.THIS_NAMESPACE, typeName); 
        return replaceCommas(nameWithNamespace);
    }

    private String replaceCommas(String typeWithNamespace) {
        return typeWithNamespace.replace('.', '/');
    }
    
    /**
     * Gets the Java array type corresponding to income array type name.
     * 
     * @param arrayTypeName e.g. <code>TestClass[][]</code>
     * @return e.g. <code>[[Lmy/test/TestClass;</code>
     */
    private String getJavaArrayType(String arrayTypeName) {   
        String[] tokens = arrayTypeName.split("\\[");
        StringBuffer strBuf = new StringBuffer();
        for (int i = 0; i< tokens.length - 1; i++) {
            strBuf.append("[");
        }
        String nameWithPackage = getTypeNameWithPackage(tokens[0]);
        
        return String.format("%sL%s;", strBuf.toString(), nameWithPackage);          
    }
}
