<html>
<head><script language=JavaScript>
<!--

//  Script generated by Search Maker Pro:

s1=new Array();s1[1]=new Array("Ref_Audience.html","Audience    ","","Audience This guide is mainly intended for developers who create applications employing the table based decision making mechanisms offered by OpenL Tablets technology. However, business analysts and other users can also benefit from this guide by learning the basic OpenL Tablets concepts described herein. To effectively use this guide, basic knowledge of Java, Eclipse, Ant, and Excel® is required.");s1[2]=new Array("Ref_BasicConcepts.html","Basic Concepts    ","","Basic Concepts This section describes the following main OpenL Tablets concepts: Rules Tables Projects Wrappers");s1[3]=new Array("Ref_BEXLanguageOverview.html","Appendix A: BEX Language Overview    ","","Appendix A: BEX Language Overview This section provides a general overview of the BEX language that can be used in OpenL Tablets expressions. The following topics are included in this section: Introduction to BEX Keywords Simplifying Expressions");s1[4]=new Array("Ref_ConfigurationTable.html","Configuration Table    ","","Configuration Table OpenL Tablets allows externalizing business logic into Excel or Word files. However, these files can still use objects and methods defined in the Java environment. To enable use of Java objects and methods in Excel or Word tables, the file must have a configuration table. A configuration table provides information to the OpenL Tablets engine about available Java packages. Another purpose of a configuration file is to point to other Excel and Word files that can be referenced in tables. A configuration table is identified by the keyword 'Environment' in the first row. No additional parameters are required. Starting with the second row, a configuration table must have two columns. The first column contains commands and the second column contains input strings for commands. The following commands are supported in configuration tables: Configuration table commands Command Description import Imports the specified Java package so that its objects and methods can be used in tables. include Includes another Excel or Word file so that its tables and data can be referenced in tables of the current file. The following is an example of a configuration table:");s1[5]=new Array("Ref_ConfiguringTheAntTaskFile.html","Configuring the Ant Task File    ","","Configuring the Ant Task File When a new OpenL Tablets project is created, it already contains an Ant task file GenerateJavaWrapper.build.xml located in the build folder. When the file is executed, it automatically creates wrapper Java classes for specified Excel or Word files. The Ant task file must be adjusted to match contents of the specific project. For each Excel or Word file, an individual &lt;openlgen&gt; section must be added between the &lt;target&gt; and &lt;/target&gt; tags. Each &lt;openlgen&gt; section has a number of parameters that must be adjusted. The following table describes &lt;openlgen&gt; section parameters: Parameters in the &lt;openlgen&gt; section Parameter Description openlName OpenL configuration to be used. For OpenL Tablets, the following value must always be used: org.openl.xls userHome Location of user defined resources relative to the current OpenL Tablets project. srcFile Reference to the Excel or Word file for which a wrapper class must be generated. targetClass Full name of the wrapper class to be generated. OpenL Web Studio recognizes modules in projects by wrapper classes and uses their names in the user interface. If there are multiple wrappers with identical names, only one of them is recognized as a module in OpenL Web Studio. displayName End user oriented title of the file that appears in OpenL Web Studio. targetSrcDir Folder where the generated wrapper class must be placed. The following is an example of the GenerateJavaWrapper.build.xml file: &lt;project name=&quot;GenJavaWrapper&quot; default=&quot;generate&quot; basedir=&quot;../&quot;&gt; &lt;taskdef name=&quot;openlgen&quot; classname=&quot;org.openl.conf.ant.JavaWrapperAntTask&quot;/&gt; &lt;target name=&quot;generate&quot;&gt; &lt;echo message=&quot;Generating wrapper classes...&quot;/&gt; &lt;openlgen openlName=&quot;org.openl.xls&quot; userHome=&quot;.&quot; srcFile=&quot;rules/Rules.xls&quot; targetClass=&quot;com.exigen.claims.RulesWrapper&quot; displayName=&quot;Rule table wrapper&quot; targetSrcDir=&quot;gen&quot; &gt; &lt;/openlgen&gt; &lt;openlgen openlName=&quot;org.openl.xls&quot; userHome=&quot;.&quot; srcFile=&quot;rules/Data.xls&quot; targetClass=&quot; com.exigen.claims.DataWrapper&quot; displayName=&quot;Data table wrapper&quot; targetSrcDir=&quot;gen&quot; &gt; &lt;/openlgen&gt; &lt;/target&gt; &lt;/project&gt;");s1[6]=new Array("Ref_CreatingAProject.html","Creating a Project    ","","Creating a Project To create a new OpenL Tablets project, create an Exigen Studio project and enable the OpenL Tablets facet in the project as described in Exigen Studio Designer's Guide. A new project is created containing simple template files that developers can use as the basis for custom rule solutions.");s1[7]=new Array("Ref_CreatingTablesForOpenLTablets.html","Chapter 2: Creating Tables for OpenL Tablets    ","","Chapter 2: Creating Tables for OpenL Tablets This section describes how OpenL Tablets processes tables and provides reference information for each table type used in OpenL Tablets. The following topics are included in this section: Table Recognition Algorithm Table Types");s1[8]=new Array("Ref_DataTable.html","Data Table    ","","Data Table A data table contains relational data that can be referenced from other tables within OpenL Tablets. In addition, information in data tables can be accessed from Java code through wrappers as Java arrays. Data tables can contain Java classes or OpenL Tablets data types. For information on data types, see Data Type Table. The following topics are included in this section: Using Simple Data Tables Using Advanced Data Tables Ensuring Data Integrity Specifying Data for Aggregated Objects Using Simple Data Tables The following is an example of a data table containing a simple array of numbers: The first row is the header containing text in the following format: Data &lt;data table type&gt; &lt;data table name&gt; In simple data tables, the keyword 'this' must be used for the following types: all primitive Java types class java.lang.String class java.util.Date all Java classes with a public constructor with a single String parameter In the example above, information in the data table can be accessed from Java code as shown in the following code example: int[] num = tableWrapper.getNumbers(); for (int i = 0; i &lt; num.length; i++) { System.out.println(num[i]); } where tableWrapper is an instance of the wrapper class of the Excel or Word file. For information on wrappers, see Wrappers. Using Advanced Data Tables Advanced data tables are used for storing information for complex constructions, such as Java beans and data types. For information on data types, see Data Type Table. The first row of an advanced data table contains text in the following format: Data &lt;Java bean or data type&gt; &lt;data table name&gt; Each cell in the second row contains an attribute name of the data type or Java bean. Normally, the second row is hidden to business users. The third row contains attribute display names. Each row starting with the fourth one contains values for specific data type instances. The following diagram shows a data type table and a corresponding data table with concrete values below it: Data tables can use Java beans instead of data types. For example, instead of using a data type table Person, a developer can use the following Java bean: public class Person { String name; String ssn; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSsn() { return ssn; } public void setSsn(String ssn) { this.ssn = ssn; } } If a Java bean is used, to avoid compilation error, the package where the Java bean is located must be imported using a configuration table as described in Configuration Table. In Java code, the data table p1 can be accessed as follows: Person[] persArr = tableWrapper.getP1(); for (int i = 0; i &lt; persArr.length; i++) { System.out.println(persArr[i].getName() + ' ' + persArr[i].getSsn()); } where tableWrapper is an instance of the Excel or Word file wrapper. For information on wrappers, see Wrappers. Ensuring Data Integrity If a data table contains values defined in another data table, it is important to specify this relationship so that OpenL Tablets can check data integrity during compilation. The relationship between two data tables is defined using foreign keys, a concept that is used in database management systems. Reference to another data table must be specified in an additional row below the row where attribute names are entered. The following format must be used: &gt; &lt;referenced data table name&gt; &lt;column name of the referenced data table&gt; In the following diagram, the data table cities contains values from the table states. To ensure users enter correct values, a reference to the code column in the states table is defined. In case user enters invalid state abbreviation in the table cities, OpenL Tablets reports an error. The target column does not have to be specified if it is the first column in the referenced data table. For example, if a reference was made to the column name in the table states, the following simplified reference could be used: &gt;states Note: To ensure users enter correct values, cell data validation lists can be used in Excel limiting the range of values users can type in. Specifying Data for Aggregated Objects Data tables can be used to specify attributes of referenced objects. An object referenced by a data table is called an aggregated object. To specify an attribute of an aggregated object, the following format must be used in the row containing data table attribute names: &lt;name of reference to the aggregated object&gt;.&lt;object attribute&gt; To illustrate this approach, assume there are two Java classes ZipCode and Address defined: public class ZipCode { String zip1; // 5-digit part - mandatory String zip2; // 4-digit part - optional public String getZip1() { return zip1; } public void setZip1(String zip1) { this.zip1 = zip1; } public String getZip2() { return zip2; } public void setZip2(String zip2) { this.zip2 = zip2; } } public class Address { String street; String city; ZipCode zip; public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getStreet() { return street; } public void setStreet(String street) { this.street = street; } public ZipCode getZip() { return zip; } public void setZip(ZipCode zip) { this.zip = zip; } } As can be seen from the code, the Address class contains a reference to the ZipCode class. A data table can be created that specifies values for both classes at the same time, for example: In the preceding example, columns Zip1 and Zip2 contain values for class ZipCode referenced by class Address. All Java classes referenced in a data table must be imported using a configuration table as described in Configuration Table. Note: The reference path can be of any arbitrary depth, for example account.person.address.street.");s1[9]=new Array("Ref_DataTypeTable.html","Data Type Table    ","","Data Type Table A data type table defines an OpenL Tablets data carrier. Data types can be used in data tables. For information on how this is done, see Data Table. The following is an example of a data type table defining a data type called Person: The first row is the header containing the keyword 'Datatype' followed by the name of the data type. Every row, beginning with the second one, represents one property of the data type. The first column contains property types; the second column contains corresponding property names.");s1[10]=new Array("Ref_DecisionTable.html","Decision Table    ","","Decision Table A decision table contains a set of rules describing decision situations where the state of a number of conditions determines the execution of a set of actions. It is the basic table type used in OpenL Tablets decision making. The following topics are included in this section: Decision Table Structure Decision Table Interpretation Transposed Decision Tables Working with Arrays Representing Date Values Representing Boolean Values Using Calculations in Table Cells Decision Table Structure The following is an example of a decision table: The following table describes its structure: Decision table structure Row number Mandatory Description 1 Yes Table header, which has the following pattern: &lt;keyword&gt; &lt;method header&gt; where &lt;keyword&gt; is either 'Rules' or 'DT' and &lt;method header&gt; is a signature of a method used to access the decision table and provide input parameters. For example, the table in the preceding diagram can be invoked as follows: HelloWrapper tableWrapper = new HelloWrapper(); tableWrapper.hello1(15); where HelloWrapper is the wrapper class of the Excel or Word file. For general information on wrappers, see Wrappers. Normally, this row is hidden to business users. 2 and 3 No Rows containing table properties. Each application using OpenL Tablets rules can utilize properties for different purposes. A predefined table property 'name' is used to specify business user oriented name of the table displayed in OpenL Web Studio. Although the provided decision table example contains two property rows, there can be any number of property rows in a table. Normally, property rows are hidden to business users. 4 Yes Row consisting of the following cell types: Type Description Examples Condition column header Identifies that the column contains rule condition and its parameters. It must start with character 'C' followed by a number. C1, C5, C8 Action column header Identifies that the column contains rule actions. It must start with character 'A' followed by a number. A1, A2, A5 Return value column header Identifies that the column contains values to be returned to the calling program. Since there can be only one return value, the only allowed content of the cell is 'RET1'. RET1 All other cells in this row are ignored and can be used as comments. If a table contains action columns, the engine executes actions for all rules whose conditions are true. If a table has a return column, the engine stops processing rules after the first executed rule. If a return column has a blank cell and the rule is executed, the engine does not stop but continues checking rules in the table. Normally, this row is hidden to business users. 5 Yes Row containing cells with code statements for condition, action, and return value column headers. OpenL Tablets supports Java grammar enhanced with OpenL Business Expression (BEX) grammar features. For information on the BEX language, see Appendix A: BEX Language Overview. Code in these cells can use any Java objects and methods visible to the OpenL Tablets engine. For information on enabling the OpenL Tablets engine to use custom Java packages, see Configuration Table. Purpose of each cell in this row depends on the cell above it as follows: Cell above Purpose Condition column header Specifies the logical expression of the condition. It can reference parameters in the method header and parameters in cells below. The cell must contain an expression returning a Boolean value. All condition expressions must be true to execute a rule. Action column header Specifies code to be executed if all conditions of the rule are true. The code can reference parameters in the method header and parameters in cells below. Return value column header Specifies expression used for calculating the return value. The type of the expression must match the return value specified in the method header. This cell can reference parameters in the method header and parameters in cells below. Normally, this row is hidden to business users. 6 Yes Row containing parameter definition cells. Each cell in this row specifies the type and name of parameters in cells below it. Parameter name must be one word corresponding to Java identification rules. Parameter type must be one of the following: primitive Java types Java classes visible to the engine one-dimensional arrays of the above types as described in Working with Arrays data tables or their attributes as described in Using Advanced Data Tables Normally, this row is hidden to business users. 7 Yes Descriptive column titles. The rule engine does not use them in calculations but they are intended for business users working with the table. Cells in this row can contain any arbitrary text. 8 and below Yes Concrete parameter values. Decision Table Interpretation Rules inside decision tables are processed one by one in the order they are placed in the table. A rule is executed only when all its conditions are true. If at least one condition returns false, all other conditions in the same row are ignored. Absence of a parameter in a condition cell is interpreted as a true value. Blank action and return value cells are ignored. Transposed Decision Tables Sometimes decision tables look more convenient in transposed format where columns become rows and rows become columns. For example, a transposed version of the previously shown decision table resembles the following: OpenL Tablets automatically detects transposed tables and is able to process them correctly. Working with Arrays If a parameter is an array type, there are two ways its values can be entered in a table. The first option is to arrange array values horizontally using multiple subcolumns. The following is an example of this approach: In this example, the contents of the set variable for the first rule are [1,3,5,7,9] and for the second rule [2,4,6,8]. Values are read from left to right. The second option is to present parameter values vertically as follows: In the second case, the boundaries between rules are determined by the height of the leftmost cell. Therefore, an additional column must be added to the table to specify boundaries between arrays. In both cases, empty cells are not added to the array. To facilitate work with arrays, OpenL Tablets provides the following method, which determines whether a particular element is included in an array: contains(Object[] ary, Object ojb) This method works only with Java objects, not primitive Java types. The following example displays a table using the contains method: Representing Date Values To represent date values in table cells, the following format must be used: '&lt;month&gt;/&lt;date&gt;/&lt;year&gt; The value must always be preceded with an apostrophe. Excel treats these values as plain text and does not convert to any specific date format. The following are valid date value examples: '5/7/1981 '10/20/2002 Representing Boolean Values OpenL Tablets supports the following formats of Boolean values: True, TRUE, Yes, YES False, FALSE, No, NO Using Calculations in Table Cells OpenL Tablets can perform mathematical calculations involving method input parameters in table cells. For example, instead of returning a concrete number, a rule can return a result of a calculation involving one of the input parameters. Calculation result type must match the type of the cell. Text in cells containing calculations must start with an apostrophe followed by =. Excel treats such values as plain text. The following decision table demonstrates calculations in table cells: The table transforms a 12 hour time format into a 24 hour time format. The column RET1 contains two cells that perform calculations with the input parameter ampmHr. Calculations use regular Java syntax, similar to what is used in conditions and actions. Note: Excel formulas are not supported by OpenL Tablets.");s1[11]=new Array("Ref_Examples.html","Examples    ","","Examples OpenL Tablets provides five example projects that demonstrate how OpenL Tablets can be used in various business domains. To create an example project, proceed as follows: In Eclipse, select File &gt; New &gt; Project. In the new project wizard, expand the OpenL Tablets &gt; Examples folder. Select an appropriate example project and click Next. In the next page, click Finish.");s1[12]=new Array("Ref_ExecutingTheAntTaskFile.html","Executing the Ant Task File    ","","Executing the Ant Task File To execute the Ant task file and generate wrappers, proceed as follows: In Eclipse, refresh the project. Execute the Ant task XML file as an Ant build. Refresh the project again so that wrapper classes are displayed in Eclipse. Once wrappers are generated, the corresponding Excel or Word files can be used in the solution.");s1[13]=new Array("Ref_GeneratingAWrapper.html","Generating a Wrapper    ","","Generating a Wrapper Access to rules and data in Excel or Word tables is realized through wrapper classes. For general information on wrappers, see Wrappers. To generate a wrapper class, proceed as follows: Configure the Ant task file as described in Configuring the Ant Task File. Execute the Ant task file as described in Executing the Ant Task File.");s1[14]=new Array("Ref_InstallingOpenLTablets.html","Installing OpenL Tablets    ","","Installing OpenL Tablets OpenL Tablets development environment is installed as an Eclipse feature delivered as part of the Exigen Process Backbone installation package. The installation process of the OpenL Tablets feature is the same as for any other Eclipse feature. The development environment is required only for creating OpenL Tablets projects and launching OpenL Web Studio. If ready OpenL Tablets projects are accessed through OpenL Web Studio or web services, no specific software needs to be installed.");s1[15]=new Array("Ref_IntroducingOpenLTablets.html","Chapter 1: Introducing OpenL Tablets    ","","Chapter 1: Introducing OpenL Tablets This section introduces OpenL Tablets and describes its main concepts. Since OpenL Tablets is part of Exigen Decision Services, a brief overview of Exigen Decision Services is also provided in this section. The following topics are included in this section: What Is Exigen Decision Services? What Is OpenL Tablets? Basic Concepts System Overview Installing OpenL Tablets Tutorials and Examples");s1[16]=new Array("Ref_IntroductionToBEX.html","Introduction to BEX    ","","Introduction to BEX BEX language allows a flexible combination of grammar and semantics by extending the existing Java grammar and semantics presented in the org.openl.j configuration using new grammar and semantic concepts. It enables users to write expressions similar to natural human language. BEX does not require any special mapping; the existing Java business object model automatically becomes the basis for open business vocabulary used by BEX. For example, Java expression 'policy.effectiveDate' is equivalent with BEX expression 'Effective Date of the Policy'. If the Java model correctly reflects business vocabulary, there is no further action required. In case the Java model is not satisfactory, custom type-safe mapping or renaming can be applied.");s1[17]=new Array("Ref_Keywords.html","Keywords    ","","Keywords BEX uses the following self-explanatory keywords: of the is less than is more than is less or equal is no more than is more or equal is no less than Because of these keywords, name clashes with business vocabulary can occur. The easiest way to avoid clashes is to use upper case notation when referring to model attributes because BEX grammar is case sensitive and all keywords are in lower case. For example, assume there is an attribute called isLessThanCoverageLimit. If it is referred as 'is less than coverage limit', a name clash with keywords 'is less than' occurs. The workaround is to refer to the attribute as 'Is Less Than Coverage Limit'.");s1[18]=new Array("Ref_MethodTable.html","Method Table    ","","Method Table A method table is a Java method described within a table. The following is an example of a method table: The first row is a table header, which has the following format: &lt;keyword&gt; &lt;return type&gt; &lt;method name and parameters&gt; where &lt;keyword&gt; is either 'Method' or 'Code'. The second row is the actual code to be executed. It can reference parameters passed to the method and all Java objects and tables visible to the OpenL Tablets engine. Method in the preceding example table can be called from Java code as follows: ApprovalRulesWrapper tableWrapper = new ApprovalRulesWrapper(); System.out.println(tableWrapper.getGreeting(&quot;John&quot;));");s1[19]=new Array("Ref_NotationOfExplanatoryVariables.html","Notation of Explanatory Variables    ","","Notation of Explanatory Variables BEX supports a notation where an expression is written using simple variables followed by the attributes they represent. For example, assume the following expression is used in Java: (Agreed Value of the vehicle - Market Value of the vehicle) / Market Value of the vehicle is more than Limit Defined By User As can be seen from the example, the expression is hard to read. However, the expression is much simpler if written according to the notion of explanatory variables as follows: (A - M) / M &gt; X, where A - Agreed Value of the vehicle, M - Market Value of the vehicle, X - Limit Defined By User This syntax is similar to the one used in scientific publications and is much easier to read for complex expressions. It provides a good mix of mathematical clarity and business readability.");s1[20]=new Array("Ref_Preface.html","Preface    ","","Preface This preface is an introduction to the Exigen Decision Services OpenL Tablets Reference Guide. The following topics are included in this preface: Audience Related Information");s1[21]=new Array("Ref_Projects.html","Projects    ","","Projects An OpenL Tablets project is a container of all resources required for processing rule related information. Usually, a project contains Excel or Word files, Java code, and Ant task for generating wrappers of table files. For detailed information on projects, see Chapter 3: Working With Projects. Depending on technical aspects of a solution, there can be situations where OpenL Tablets projects are used in development environment but not in production.");s1[22]=new Array("Ref_ProjectStructure.html","Project Structure    ","","Project Structure To use the OpenL Tablets rule technology in a solution, an OpenL Tablets project must be created in Eclipse. An OpenL Tablets project is an Exigen Studio project with an OpenL Tablets facet. Typically, an OpenL Tablets project contains the following general elements: OpenL Tablets project contents Element Description Excel or Word files Physical storage of rules and data in the form of tables. Ant task for generating file wrappers Ant configuration file used for creating wrapper classes for Excel or Word files so that they can be accessed from code. For general information on wrappers, see Wrappers. Wrappers Java classes providing access to OpenL Tablets objects in Excel or Word files. Wrappers must be generated as described in Generating a Wrapper. Additional Java code Optional classes for domain models and for processing or testing rules in the project. Solution developers can decide whether to include additional code in OpenL Tablets projects. The following table describes OpenL Tablets specific folders in the physical project structure: OpenL Tablets project structure Folder Contents src Contains all project Java classes apart from wrappers. rules Contains Excel or Word files. gen Contains generated wrapper classes. bin Contains compiled Java code. build Contains Ant configuration file for generating wrapper classes. For information on generating wrappers, see Generating a Wrapper.");s1[23]=new Array("Ref_RelatedInformation.html","Related Information    ","","Related Information The following table lists sources of information related to contents of this guide: Related information Title Description OpenL Web Studio User's Guide Document describing OpenL Web Studio, a web application for managing OpenL Tablets projects through web browser. Exigen Studio Designer's Guide Document describing the Exigen Process Backbone development environment. http://ant.apache.org/ Website describing how to install and use Ant, a Java-based build tool. http://openl-tablets.sourceforge.net/ OpenL Tablets open source project website. Exigen Decision Services BLS Developer's Guide Document describes BLS, another rule processing framework included in Exigen Decision Services. &nbsp;");s1[24]=new Array("Ref_Rules.html","Rules    ","","Rules In OpenL Tablets, a rule is a logical statement consisting of conditions and actions. If a rule is called and all its conditions are true then the corresponding actions are executed. Basically, a rule is an IF-THEN statement. The following is an example of a rule expressed in human language: If a service request costs less than 1,000 dollars and takes less than 8 hours to execute then the service request must be approved automatically. Instead of executing actions, rules can also return data values to the calling program.");s1[25]=new Array("Ref_RunMethodTable.html","Run Method Table    ","","Run Method Table A run method table calls a particular decision table or method table multiple times and provides input values for each individual call. Therefore, run method tables are similar to test tables, except they do not perform a check of values returned by the called method. Note: Run method tables can be used to execute any Java method but in that case a method table must be used as a proxy. The following is an example of a run method table: This example assumes there is a method append defined with two input parameters, firstWord and secondWord. The run method table calls this method three times with three different sets of input values. A run method table has the following structure: The first row is a table header, which has the following format: Runmethod &lt;method to call&gt; &lt;run method table name&gt; The second row contains cells with method input parameter names. Starting with the third row, each row is a set of input parameters to be passed to the called method.");s1[26]=new Array("Ref_SimplifyingExpressions.html","Simplifying Expressions    ","","Simplifying Expressions Unfortunately, the more complex an expression is, the less comprehensible the natural language expression becomes in BEX. For this purpose, BEX provides the following methods for simplifying expressions: Notation of Explanatory Variables Uniqueness of Scope");s1[27]=new Array("Ref_SystemOverview.html","System Overview    ","","System Overview The following diagram shows how OpenL Tablets is used by different types of users: The following is a typical lifecycle of an OpenL Tablets project: A rule developer creates a new OpenL Tablets project in Eclipse. In addition to the project itself, the rule developer also creates correctly structured tables in Excel or Word files based on requirements and includes them in the project. A business user accesses tables in the OpenL Tablets project and defines rules. Typically, this task is performed through OpenL Web Studio in a web browser. A rule developer performs unit tests and performance tests on rules through advanced OpenL Web Studio features. A developer who creates other parts of the solution employs business rules directly through the OpenL Tablets engine or remotely through web services. Whenever required, the business user updates or adds new rules to project tables.");s1[28]=new Array("Ref_TableRecognitionAlgorithm.html","Table Recognition Algorithm    ","","Table Recognition Algorithm This section describes the algorithm of how the OpenL Tablets engine looks for supported tables in Excel or Word files. It is important to build tables according to requirements of this algorithm; otherwise the tables will not be correctly recognized. OpenL Tablets utilizes Excel concepts of workbooks and worksheets. These can be represented and maintained in multiple Excel files. Each workbook is comprised of one or more worksheets used to separate information by categories. Each worksheet, in turn, is comprised of one or more tables. Workbooks can include tables of different types, each of which can support a different underlying logic. The following is the general table recognition algorithm: The engine looks into each spreadsheet and tries to identify logical tables. Logical tables must be separated by at least one empty row or column or start at the very first row or column. Table parsing is performed from left to right and from top to bottom. The first populated cell that does not belong to a previously parsed table becomes the top-left corner of a new logical table. The engine reads text in the top left cell of a recognized logical table to determine its type. If the top left cell of a table starts with a predefined keyword then such table is recognized as an OpenL Tablets table. The following are the supported keywords: Table type keywords Keyword Table type Rules or DT Decision Table Data Data Table Datatype Data Type Table Testmethod Test Table Runmethod Run Method Table Method or Code Method Table Environment Configuration Table All tables that do not have any of the preceding keywords in the top left cell are ignored. They can be used as comments in Excel or Word files. The engine determines the width and height of the table using populated cells as clues. It is good practice to merge all cells in the first table row, so the first row explicitly specifies the table width. The first row is called the table header. To put a table title before the header row, an empty row must be used between the title and the first row of the actual table.");s1[29]=new Array("Ref_Tables.html","Tables    ","","Tables Basic information OpenL Tablets deals with, such as rules and data, is presented in tables. Different types of tables serve different purposes. For detailed information on table types, see Table Types.");s1[30]=new Array("Ref_TableTypes.html","Table Types    ","","Table Types OpenL Tablets employs the following table types: Decision Table Data Type Table Data Table Test Table Run Method Table Method Table Configuration Table");s1[31]=new Array("Ref_TestTable.html","Test Table    ","","Test Table A test table is used to perform unit tests on decision tables and method tables. It calls a particular method, provides test input values, and checks whether the returned value matches the expected value. Test tables are mostly used for testing decision tables. Note: Test tables can be used to execute any Java method but in that case a method table must be used as a proxy. For example, in the following diagram, the table on the left is a decision table but the table on the right is a unit test table that tests data of the decision table: A test table has the following structure: The first row is the table header, which has the following format: Testmethod &lt;method name&gt; &lt;test table name&gt; 'Testmethod' is a keyword that identifies a test table. The second parameter is the name of the decision table method or any other Java method to be tested. The third parameter is the name of the test table, which is also the name of the method by which the test table can be executed from Java code. The second row provides a separate cell for each input parameter of the decision table method followed by column _res_, which contains the expected test result values. The third row contains display values intended for business users. Starting with the fourth row, each row is an individual test run. When a test table is called, the OpenL Tablets engine calls the specified method for every row in the test table and passes the corresponding input parameters to it. Test results can be accessed through the test table API. For example, the following code fragment executes all test runs in a test table called insuranceTest and displays the number of failed test runs: TableWrapper tableWrapper = new TableWrapper(); TestResult tr = tableWrapper.insuranceTestTestAll(); System.out.println(&quot;Number of failed test runs: &quot;+tr.getNumberOfFailures()); If OpenL Tablets projects are accessed and modified through OpenL Web Studio, the user interface provides more advanced and convenient utilities for running tests and viewing test results. For information on using OpenL Web Studio, see OpenL Web Studio User's Guide.");s1[32]=new Array("Ref_Tutorials.html","Tutorials    ","","Tutorials OpenL Tablets provides five tutorial projects demonstrating basic OpenL Tablets features beginning very simply and moving on to more advanced projects. Files in the tutorial projects contain detailed comments allowing new users to grasp basic concepts quickly. To create a tutorial project, proceed as follows: In Eclipse, select File &gt; New &gt; Project. In the new project wizard, expand the OpenL Tablets &gt; Tutorials folder. Select an appropriate tutorial project, and click Next. In the next page, click Finish.");s1[33]=new Array("Ref_TutorialsAndExamples.html","Tutorials and Examples    ","","Tutorials and Examples The OpenL Tablets Eclipse feature contains several preconfigured projects intended for new users who want to learn working with OpenL Tablets quickly. These projects are organized into following groups: Tutorials Examples");s1[34]=new Array("Ref_UniquenessOfScope.html","Uniqueness of Scope    ","","Uniqueness of Scope BEX provides another way for simplifying expressions using the concept of unique scope. For example, if there is only one policy in the scope of expression, the user can write 'effective date' instead of 'effective date of the policy'. BEX automatically determines the uniqueness of the attribute and either produces a correct path or emits an error message in case of ambiguous statement. The level of the resolution can be modified programmatically and by default equals 1.");s1[35]=new Array("Ref_WhatIsExigenDecisionServices.html","What Is Exigen Decision Services?    ","","What Is Exigen Decision Services? Exigen Decision Services is a collection of frameworks for rapidly creating, deploying, and maintaining rules-based systems in financial services, insurance, telecommunications, and other industries. Exigen Decision Services consists of the following main frameworks: Main Exigen Decision Services frameworks Framework Description OpenL Tablets Rules management framework based on tables presented in Excel and Word documents. For general overview of OpenL Tablets, see What Is OpenL Tablets?. Only this framework of Exigen Decision Services is described in this document. Business Logic Services (BLS) Framework designed to work with rules describing constraints and logic associated with data object attributes. Rules attached to a JSF form provide user input validation that is centrally declared, reused across screens, and executed on both client and server sides. For detailed information on BLS, see Exigen Decision Services BLS Developer's Guide.");s1[36]=new Array("Ref_WhatIsOpenLTablets.html","What Is OpenL Tablets?    ","","What Is OpenL Tablets? OpenL Tablets is a rules management framework based on tables presented in Excel and Word documents. Using unique concepts, OpenL Tablets facilitates treating business documents containing business logic specifications as executable source code. Since the format of tables used by OpenL Tablets is familiar to business users, OpenL Tablets bridges a gap between business users and developers, thus reducing costly enterprise software development errors and dramatically shortening the software development cycle. In a very simplified overview, OpenL Tablets can be considered as a table processor that extracts tables from Excel and Word documents and makes them accessible from Java programs. OpenL Tablets is built using the OpenL technology providing a framework for development of different language configurations. The major advantages of using OpenL Tablets are as follows: OpenL Tablets removes the gap between software implementation and business documents, rules, and policies. Business rules become transparent to Java developers. For example, decision tables are transformed into Java methods, and data tables become accessible as Java data arrays through the familiar getter and setter JavaBeans mechanism. The transformation is performed automatically. OpenL Tablets verifies syntax and type errors in all project document data, providing convenient and detailed error reporting. OpenL Tablets is able to directly point to a problem in an Excel or Word document. OpenL Tablets provides calculation explanation capabilities, enabling expansion of any calculation result by pointing to source arguments in the original documents. OpenL Tablets provides cross-indexing and search capabilities within all project documents. OpenL Tablets supports the .xls and .doc file formats.");s1[37]=new Array("Ref_WorkingWithProjects.html","Chapter 3: Working With Projects    ","","Chapter 3: Working With Projects This section describes creating an OpenL Tablets project. For general information on projects, see Projects. The following topics are included in this section: Project Structure Creating a Project Generating a Wrapper");s1[38]=new Array("Ref_Wrappers.html","Wrappers    ","","Wrappers A wrapper is a Java class that exposes decision tables as Java methods, data tables as Java objects and allows developers to access table information from code. To access a particular table from Java code, a wrapper Java class must be generated for the Excel or Word file where the table is defined. Wrappers are essential for solutions where compiled OpenL Tablets project code is embedded in solution applications. If tables are accessed through web services, client applications are not aware of wrappers but they are still used on the server. OpenL Tablets provides a specific Ant task that can be used for static generation of a wrapper from any Excel or Word file automatically. A wrapper class must be regenerated in the following situations: A table signature, such as method name, input parameters, and return values, is modified. A table is added or deleted in the corresponding file. Wrapper classes do not have to be regenerated if table data is modified or if conditions and actions are added or removed. For information on generating wrappers, see Generating a Wrapper.");var sb=0;var sc=1;var sd=2;var se=3;var sf=4;var sg=5;var sh=6;var si=7;var sj=8;var sk;var sl;var sm;var sn; var s98 ; var sB=true;var sC=1;var sE=2;var sD=3;var sF=4;var sP=false;var sQ=true;var s46=true;var s83=true;var s73=true;var s14=true;var s17=true;var s90=-1;var s45;var sT;function SMPSetFocus() { document.formSearch.txtSearch.focus(); }
function sp(sq) {if ((sq>="a" && sq<="z") || (sq=="&") ||(sq>="A" && sq<="Z") || (sq>="0" && sq <="9")) { return true; } else { return false; } }function sr( st, su, sv ) {var sy;var sz, s7, s2; var s3=0; var s42; var s43=true; var s44;s1[st][sg]=0;for( s42=0; s42<s41.length; s42++ ){ if (s41[s42].length>0) { sy=s1[st][su];if ( !s17 ){ sy=sy.toUpperCase(); } sz=sy.indexOf( s41[s42] );s44=s1[st][sg];while (sz >= 0){ s3 = s3 + sz + 1;if(( sm== -2 ) || ( sm== -5 )) { s7 = false; } else { if (sz == 0) { s7=false; } else { s7=sp(sy.charAt(sz-1)); }  } if(( sm == -3 ) || ( sm == -5 )) { s2 = false; } else { if ( sy.length - sz == s41[s42].length) { s2 = false; } else { s2 = sp(sy.charAt(sz + s41[s42].length)); }  } if (!s7 && !s2) { s1[st][sj+s1[st][sg]] = s3 - 1;s1[st][sg] ++; } sy = sy.substring(sz+1,sy.length);while( sp(sy.charAt(0)) && sy.length > 0 ) { sy = sy.substring( 1, sy.length ) ;s3 ++; } sz = sy.indexOf(s41[s42]); } if( s1[st][sg] == s44) { s43=false; } } } if( (s45==2) && (s43==false) ) { s1[st][sg]=0; } } function s4(st, sv) { var su=-1, s5; var ak=9268437382677; s1[st][sf]=-1;while( ++su <= se && s1[st][sf]==-1 ) { s5 = su==0 ? sc : (su==1 ? sd : (su==2 ? sb : se));if( ((s5 == sc ) && ( s46 )) || ((s5 == sd ) && ( s83 )) || ((s5 == sb ) && ( s73 )) || ((s5 == se ) && ( s14 )) ) { sr( st, s5, sv ); } else { s1[st][sg]=0 } if ( s1[st][sg] > 0 ) { s1[st][sf] = s5; } } s="searchmaker";t=eval(s.charAt(2)+s.charAt(8)); } function s6() { var st, su, s79, s8;for( st=1; st<s1.length; st++ ) { s1[st][si] = st; } if( sB ) {for( st=1; st<s1.length; st++ ) { if( s1[st][sf] == sc ) { s1[st][sh] = (4-sC) * 15000; } else if( s1[st][sf] == sd ) { s1[st][sh] = (4-sE) * 15000; } else if( s1[st][sf] == sb ) { s1[st][sh] = (4-sD) * 15000; } else { s1[st][sh] = (4-sF) * 15000 + s1[st][sg]; } } for( st=2; st<s1.length; st++ ) { s79 = s1[st][sh]; s8 = s1[st][si];for( su=st; su>1 && s79 > s1[su-1][sh]; su--) { s1[su][sh] = s1[su-1][sh];s1[su][si] = s1[su-1][si]; }s1[su][sh] = s79;s1[su][si] = s8; } } } function s9(st) { var sA = s1[st][sg]==1 ? "match" : "matches";sk += ""; sk += ""; if( s1[st][sf]==sc ) { sk += " - matched title"; } else { if( s1[st][sf]==sd ) {sk += " - matched description"; } else { if( s1[st][sf]==sb ) { sk += " - matched URL"; } else { sk += " - " + s1[st][sg] + " " + sA + "";  } } } sk += ""; sk += ""; } function sG(st, sH) { var sI;var sJ;var sK = false; var sL=s1[st][sj + sH - 1]; sI = sL<35 ? sI=0 : sI=sL-35;sJ = (sL+35 > s1[st][se].length) ? sJ=s1[st][se].length : sJ=sL+35;while ((sI>=0) && !sK) { if(sp(s1[st][se].charAt(sI))) { sI--; } else { sK=true; } } sI++;sK=false;while ((sJ > sL) && !sK) { if(sp(s1[st][se].charAt(sJ))) { sJ--; } else { sK=true; } } sk += "<BR>\".. "+s1[st][se].substring(sI,sL); sk += "<B>" + s1[st][se].substring(sL , sL + sl.length ) +"</B>";sk += s1[st][se].substring(sL + sl.length ,sJ) + " ..\""; } function sN( st ) { if( sP==false ) { var su=1; while ( (su < 4) && (su<=s1[st][sg])) { sG( st, su ); su++; } } } function sR( sy, sL ) { sk += sy.substring( 0, sL );sk += "<B>" + sy.substring( sL , sL + sl.length ) +"</B>";sk += sy.substring( sL + sl.length ,sy.length ); } function sU( st, sT ) { sk += "<p>" + sT +". ";sk += "<a href=\""+s1[st][sb]+"\">"+s1[st][sc]+"</a>";if (( s1[st][sf]==se ) && (s45==0)) { sN(st); } else { sk+=""; } if( (s1[st][sf]==sd ) && (s45==0)) { sk += "<br>Description: "; sk += "";sR( s1[st][sd], s1[st][sj] ); sk += ""; } else { if( s1[st][sd].length > 0 ) { sk += "<br>Description: "; sk += "" + s1[st][sd]; } else {  } } sk += ""; sk+= "<br>";sk += ""; if(( s1[st][sf]==sb ) && (s45==0)) { sR( s1[st][sb], s1[st][sj] ); } else { sk += s1[st][sb]; } sk += ""; if( sQ ) { s9( st ); } sk += "<br>"; }; function sV() { sT = 0;if (! (sn )) { for( var st=1; st<s1.length; st++ ) { if(( s1[s1[st][si]][sg] > 0 ) && (( sT < s90 ) || ( s90 == -1 ))) { sU(s1[st][si], ++sT); } }  } else { if( sm == -4 ) { sk += "<BR>ERROR: The wildcard character (*) must be at the beginning or end of the text."; } }  } function sW() { sk += "<html> <head> <title>Search Results</title> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"> <link href=\"Exigenstyle.css\" rel=\"stylesheet\" type=\"text/css\"> </head> <body bgcolor=\"#FFFFFF\" text=\"#000000\"> <h1>Search Results</h1> "; sk += "";sk += "<p>You searched for <b>" + s98 +".</b>"; sk += "" }; function sY() { if(sT==0) { sk += "<p>No pages matched your search.&nbsp;&nbsp;"; } else { var sA = sT==1 ? "page shown." : "pages shown."; sk += "<p>" + sT + " " + sA + "&nbsp;"; } sk += "<a href=\"javascript:history.go(-1)\">Search Again</a></p>"; sk += "</body> </html> "; } function s11() { var s23 = sk;document.open(); document.write(s23); document.close(); } function s03( sy ) { var sqh="";for( var st=0; st<sy.length; st++) { if( sy.charAt(st)=="<" ) { sqh += "&lt;"; } else if( sy.charAt(st)==">" ) { sqh += "&gt;"; } else if( sy.charAt(st)=="\"" ) { sqh += "&quot;"; } else { sqh += sy.charAt(st); } } return( sqh ); } function s93() { sm = sl.indexOf("*"); if( sm == 0 ) { sm = -2; sn = false; } else if (sm == sl.length -1) { sm = -3; sn = false; } else if (sm > 0 ) { sm = -4;sn = true; } else { sn = false; } if ( sl.indexOf("*") != sl.lastIndexOf("*") ) { if( sm == -2 ) { if( sl.lastIndexOf("*") == sl.length - 1 ) { sm = -5; } else { sm = -4; sn = true; } } }if( ( sm == -2 ) || (sm == -5 )) { sl = sl.substring( 1, sl.length ); } if( ( sm == -3 ) || (sm == -5 )) { sl = sl.substring( 0, sl.length - 1 ); } } function startsearch() { s17 = (document.formSearch.FormCaseSensitive.checked == true);s45 = (document.formSearch.FormSearchMode[document.formSearch.FormSearchMode.selectedIndex].value);var sv;sl=document.formSearch.txtSearch.value;if (( sl.length > 0 )&&( sl != "*" )) { sk = "";s98 = sl; sl = s03(sl);s93();if( s17 ) { sv = sl; } else { sv = sl.toUpperCase(); }if (s45 != 0) { s41=sv.split(' '); } else { s41=sv.split(); }if ( !(sn ) ) { for( var st=1; st<s1.length; st++ ) { s4( st, sv ); } s6(); } sW();sV();sY();s11(); } } 

//  End of Search Maker Pro script.

//-->
</script>
<title>Search Page</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="Exigenstyle.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#FFFFFF" text="#000000">
<h1>Search Page</h1>

<form name=formSearch action="javascript:startsearch() //">
<input name=txtSearch>&nbsp; <input name=send type=submit value=Search>
<p><select size="1" name="FormSearchMode"><option value="0">Search for words "as a phrase"</option><option value="1">Search for any of the words</option></select><br><br><input type="checkbox" name="FormCaseSensitive">Case Sensitive<br></form>

<h2>Searching Tips</h2>
<ul>
  <li>To search for all search phrase words, from the drop-down list, select <b>Search 
    for words &quot;as a phrase&quot;.</b> </li>
  <li>To search for any search phrase word, from the drop-down list, select <b>Search 
    for any of the words.</b></li>
  <li>To perform a case sensitive search, select <b>Case Sensitive.</b></li>
  <li>To perform a wildcard search, use the asterisk (*) character. It can only 
    appear at the beginning or end of the search phrase.<br>
    Examples: 
    <ul>
      <li> <b>the*</b> matches the, them, their, themselves </li>
      <li> <b>*ing</b> matches surfing, browsing, searching </li>
      <li> <b>*net*</b> matches network, intranets, internet <br>
      </li>
    </ul>
  </li>
</ul>
</body>
</html>

