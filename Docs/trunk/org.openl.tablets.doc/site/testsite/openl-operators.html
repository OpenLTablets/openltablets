<h2>OpenL Programming Language Framework Design Principles</h2>


OpenL principles are logical consequences of the simple considerations one 
can make looking at the simple language expression
<p>
driver.age < 25
<p>


From the semantic perspective, the expression intents to define the relationship 
between some value defined by 'driver.age' expression and literal '25'. One might guess,
that the English semantic of the statement could be any of 
<i>if age of the driver is less than 25 years</i> or 
<i>select drivers who are younger than 25 years old</i> or some other. 

<p>
From the programming language perspective,  the semantic part is irrelevant,
the statement should be  
<li>a <i>valid</i> statement in the language grammar
<li>a statement should be correct from the type-checking point of view
<li>if language is compiled, the valid binary code or some other results of 
compilation(for example bytecode, or code in some target language might be considered
also the results of compiling) 
should be produced form this statement
<li>some kind of runtime system, interpreter or Virtual Machine should be able to execute 
this statement's compiled form and produce the result   




<h3>OpenL Grammars</h3>

When OpenL parser parses an OpenL expression it produces the Syntax Tree. 
Each Tree Node has a node type, a literal value, reference to the source code
for displaying errors and debugging and may contain children nodes. This is similar 
to what other parsers do, with one notable exception - OpenL Grammar is not hard-coded,
it can be configured, and different can be used. Having said this, we also must say that
for the paractical purposes, as of today, we have the following grammars implemented in 
OpenL: <b>org.openl.j</b>  - based on "classic" Java 1.3 grammar (no templates and exception handling) and 
<b>org.openl.bex</b> - which is basically org.openl.j grammar with "business natural language"
extensions. The latter is used by default in OpenL Tablets business rules product.
<p>
We have experimental <b>org.openl.n3</b> grammar and we may add <b>org.openl.sql</b> grammar in the future.
<p>

The Syntax Tree produced by the <b>org.openl.j</b> grammar will look like this:

<pre>
        &lt;
       / \
      .   25
     / \
driver  age
  	
</pre>
 
The node types of the nodes are 

<li><code>op.binary.lt</code> for '&lt;'
<li><code>literal.integer</code> for '25'
<li><code>chain</code> for '.'
<li><code>identifier</code> for 'driver'
<li><code>identifier</code> for 'age'

The node type names have a significance as we will see later, but at this point they have been chosen 
rather randomly.

<p>
NOTE. It is also important to recognize that the Grammar we use in <b>org.openl.j</b> is similar not
only to Java but to any other language in C/C++/Java/C# family. This makes OpenL easily learned and
accepted by the huge pool of available programmers and adds to it's strength. The proliferation
of new languages like Ruby, Groovy, multiple proprietary languages used in  different Business Rules
Engines introduced not only the new semantics to the programming community, but also a bunch of new grammars 
that make the acceptance of the new technologies much harder. In OpenL we made significant effort to stay as 
close to the Java syntax as possible to make sure that the "entities should not be multiplied beyond necessity".    

     
<h3>Context, Variables and Types</h3>


After the Syntax Tree had been created, the next stage of the compilation process, or Binding,
binds syntax nodes to it's semantic definitions. At this stage, OpenL uses specific Binders for 
each node type. The modular structure of OpenL allows to define custom Binders for each node type.
Once syntax node had been bound into Bound Node, it has been assigned a type, making the process type-safe.
<p>
Most of the time, the standard Java approach is used to assign type to the variable - it should be defined somewhere in the 
context of the OpenL framework. Typical examples include:

<li>Method parameter
<li>Local Variable
<li>Member of surrounding class (in case of OpenL it is usually the implementation of IOpenClass called Module)
<li>External types accessed as static, mostly Java classes that are imported into OpenL   
<li>Fields and Methods in binding context - this is a feature that does not exist in Java; OpenL allows programmatically 
add custom types, fields and methods into Binding Context; for different examples of how it could be done you need to investigate 
the source code of OpenLBuilder classes in different packages. For example, <code>org.openl.j</code> automatically imports all the classes from 
the <code>java.util</code>  in addition to the standard <code>java.lang</code>. 

   
  
     
 
     



         




It had been said that OpenL gives you an ability to redefine Operators. 
In this article we will elaborate a bit on this statement. In addition, 
we will give you insight into OpenL internals and how it can be used by 
you for many other things.

<h3>OpenL Principles</h3>

OpenL has the following underlying principles at it's core:

<li><b>OpenL Type System</b>

Everybody knows that Java is a type-safe language. But it's type-safety ends when 
Java has to deal with types that lie outside of Java type system - like database tables, 
http requests or XML files. There are two approaches to deal with those "external" types -
use API or use code-generation. API approach is inherently not type-safe, it treats
attribute as literal strings, therefore even spelling errors will be visible only in runtime.
Another problem with API - it is well, API-specific, so unless the standard API exists, your 
program becomes dependent on the particular API. The approach with code-generation is better, but it 
also introduce an extra building step and is dependent on particular generator, especially 
the part where names and name spaces are converted into Java names and packages. Often, 
the generators introduce dependencies with runtime libraries that also affect the portability 
of the code. Finally, generators usually require full conversion from external data into 
Java objects, that may incur performance penalty in case where you need to access only few
attributes. OpenL Open Type system gives the simple way to add new types into OpenL language,
all you need is to define a class object that implements IOpenClass interface and add it to OpenL 
type system. The implementation can vary, but access to object's attributes and methods
will have the same syntax and provide the same type-checking in all OpenL code throughout your application.

<p>
        

   
     

