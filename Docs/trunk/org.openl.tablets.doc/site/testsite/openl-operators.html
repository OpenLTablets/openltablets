<h2>OpenL Programming Language Framework Design Principles</h2>

As we all know, Business Rules consist of rules.
Each Rule has Condition and Action. Condition is a boolean expression (the one that returns <i>true</i> or <i>false</i>).
Action can be any sequence(usually simple) of programming statements. What kind of language is most 
suitable for this task?    
   
<p>
Let's take a look at the expression, that probably is as ubiquitous in any BR doc as "if customer's level is GOLD "

<p>
<pre>driver.age < 25</pre>
<p>


From the semantic perspective, the expression intents to define the relationship 
between some value defined by 'driver.age' expression and literal '25'. One might guess,
that the English semantic of the statement could be any of 
<i>if age of the driver is less than 25 years</i> or 
<i>select drivers who are younger than 25 years old</i> or some other. 

<p>
From the programming language perspective,  the semantic part is irrelevant,
the statement should only be  
<li>a <i>valid</i> statement in the language grammar
<li>a statement should be correct from the type-checking point of view
<li>if language is compiled, the valid binary code or some other results of 
compilation(for example bytecode, or code in some target language might be considered
also the results of compiling) 
should be produced form this statement
<li>some kind of runtime system, interpreter or Virtual Machine should be able to execute 
this statement's compiled form and produce the result   




<h3>OpenL Grammars</h3>

When OpenL parser parses an OpenL expression it produces the Syntax Tree. 
Each Tree Node has a node type, a literal value, reference to the source code
for displaying errors and debugging and may contain children nodes. This is similar 
to what other parsers do, with one notable exception - OpenL Grammar is not hard-coded,
it can be configured, and different can be used. Having said this, we also must say that
for the paractical purposes, as of today, we have the following grammars implemented in 
OpenL: <b>org.openl.j</b>  - based on "classic" Java 1.3 grammar (no templates and exception handling) and 
<b>org.openl.bex</b> - which is basically org.openl.j grammar with "business natural language"
extensions. The latter is used by default in OpenL Tablets business rules product.
<p>
We have experimental <b>org.openl.n3</b> grammar and we may add <b>org.openl.sql</b> grammar in the future.
<p>

The Syntax Tree produced by the <b>org.openl.j</b> grammar will look like this:

<pre>
        &lt;
       / \
      .   25
     / \
driver  age
  	
</pre>
 
The node types of the nodes are 

<li><b>op.binary.lt</b> for '&lt;'
<li><b>literal.integer</b> for '25'
<li><b>chain</b> for '.'
<li><b>identifier</b> for 'driver'
<li><b>identifier</b> for 'age'

<p>
The node type names have are significant, as we will see later, but at this point they have been chosen 
rather randomly.

<p>
NOTE. It is also important to recognize that the Grammar we use in <b>org.openl.j</b> is similar not
only to Java but to any other language in C/C++/Java/C# family. This makes OpenL easily learned and
accepted by the huge pool of available programmers and adds to it's strength. The proliferation
of new languages like Ruby, Groovy, multiple proprietary languages used in  different Business Rules
Engines, CEP Engines etc., introduced not only the new semantics to the programming community, 
but also a bunch of new grammars that make the acceptance of the new technologies much harder.
<p> 
In OpenL we made significant effort to stay as close to the Java syntax as possible to make 
sure that the "entities should not be multiplied beyond necessity". It worth mentioning that 
some CEP Engines use SQL grammar, as the basis for their language - and for  this they 
get a praise here.

     
<h3>Context, Variables and Types</h3>


After the Syntax Tree had been created, the next stage of the compilation process, or Binding,
binds syntax nodes to it's semantic definitions. At this stage, OpenL uses specific Binders for 
each node type. The modular structure of OpenL allows to define custom Binders for each node type.
Once syntax node had been bound into Bound Node, it has been assigned a type, making the process type-safe.
<p>
Most of the time, the standard Java approach is used to assign type to the variable - it should be defined somewhere in the 
context of the OpenL framework. Typical examples include:

<li>Method parameter
<li>Local Variable
<li>Member of surrounding class (in case of OpenL it is usually the implementation of IOpenClass called Module)
<li>External types accessed as static, mostly Java classes that are imported into OpenL   
<li>Fields and Methods in binding context - this is a feature that does not exist in Java; OpenL allows programmatically 
add custom types, fields and methods into Binding Context; for different examples of how it could be done you need 
to take a good look at 
the source code of OpenLBuilder classes in different packages.  
For example, <b>org.openl.j</b> automatically imports all the classes from 
the <b>java.util</b>  in addition to the standard <b>java.lang</b> package. 



<h3>OpenL Type System</h3>

Everybody knows that Java is a type-safe language. But it's type-safety ends when 
Java has to deal with types that lie outside of Java type system - like database tables, 
http requests or XML files. There are two approaches to deal with those "external" types -
use API or use code-generation. API approach is inherently not type-safe, it treats
attribute as literal strings, therefore even spelling errors will be visible only in runtime.
Another problem with API - it is well, API-specific, so unless the standard API exists, your 
program becomes dependent on the particular API. The approach with code-generation is better, but it 
also introduce an extra building step and is dependent on particular generator, especially 
the part where names and name spaces are converted into Java names and packages. Often, 
the generators introduce dependencies with runtime libraries that also affect the portability 
of the code. Finally, generators usually require full conversion from external data into 
Java objects, that may incur performance penalty in case where you need to access only few
attributes. OpenL Open Type system gives the simple way to add new types into OpenL language,
all you need is to define a class object that implements IOpenClass interface and add it to OpenL 
type system. The implementation can vary, but access to object's attributes and methods
will have the same syntax and provide the same type-checking in all OpenL code throughout your application.


<h3>Operators</h3>

Operators are just another methods with priorities defined by the grammar. 
OpenL has 2 major types of operators: unary and binary. 
In addition, there are other operator types used in special cases.  

Here is a <a href="#oplist">complete list</a> of openl operators used in org.openl.j Grammar - the one that 
is used by default in OpenL Tablets 
product.
<p>
When we say that OpenL has a modular structure, we not only refer to the fact that 
OpenL has configurable, high-level separate components like Parser and Binder, it as also,
that each node type can have it's own NodeBinder. At the same time, we can assign the single
NodeBinder to a group of operators, like we do in case of <b>op.binary</b>.
 
<p><b>NOTE</b>.(op.binary.or '||' and op.binary.and '&&' have separate NodeBinders to provide short-circuiting).


For all other binary operators OpenL uses simple algorithm,based on the type name. For example, if node type
is 'op.binary.add', algorithm looks for the method named 'add' in the following order:
<p>
<ul>
<li><code>T? add(T1 p1, T2 p2)</code> in namespace <b>org.openl.operators</b> in the BindingContext 
<li><code>public T? T1.add(T2 p2)</code> in T1
<li><code>static public T? T1.add(T1 p1, T2 p2)</code> in T1
<li><code>static public T? T2.add(T1 p1, T2 p2)</code> in T2
</ul>

<p>
The found method is then being executed in runtime. So, if you need to to override binary operator t1 X t2
(where t1, t2 are objects of classes T1, T2 ), you need to do
the following steps:
<p>
<ol>
<li>Check <a href="oplist">Operators Table</a> and find the operator's type name.
<li>The last part of the type name will give you the name of the method that you need to implement
<li>Now you have the following options for implementing operators:
<ul> 
<li>put it into some class YourCustomOperators as the static method and register the class as the library in 
<b>org.openl.operators</b> namespace (see OpenLBuilder code for more details).
<li>implement as method in T1: <code>public T? name(T2 p2)</code>
<li>implement as method in T1: <code>static public T? name(T1 p1,T2 p2)</code>
<li>implement as method in T2: <code>static public T? name(T1 p1,T2 p2)</code>
</ul>
The list is asymmetric with regard to T1 and T2 because most of the binary operators are asymmetric. It means, that
if T1 and T2 are different, you need to define both X(T1, T2) and X(T2, T1), if both are used.
 
</ol>

<p>
For unary operators, the same approach applies,  the only difference is that there is only one parameter to deal with.

<p>

<h3>Cast Operators</h3>

Cast Operators in general correspond to Java guidelines and come in 2 types: <b>cast</b> and <b>autocast</b>.
<b>T2 autocast(T1 from, T2 to)</b> methods used to overload implicit cast operators (like from int to long, so that actually no cast operators are required in code), 
T2 cast(T1 from, T2 to) methods are used with explicit cast operators.
<p><b>NOTE</b>It is important to remember that while both cast and autocast methods require 2 parameters, only <b>T1 from</b>
parameter will be actually used. The second parameter is needed to avoid ambiguity in Java method resolution 
  



 



<a name="oplist"/>
<h3>Appendix</h3> 

<h3>A. The List of org.openl.j Operators</h3>

In the order of priority:

<p>
<table border=1>

<tr><td colspan=2>Assignment operators</td></tr>

<tr><td><pre>=</td><td><pre>op.assign</pre></td></tr>
<tr><td><pre>+=</td><td><pre>op.assign.add</pre></td></tr>
<tr><td><pre>-=</td><td><pre>op.assign.subtract</pre></td></tr>
<tr><td><pre>*=</td><td><pre>op.assign.multiply</pre></td></tr>
<tr><td><pre>/=</td><td><pre>op.assign.divide</pre></td></tr>
<tr><td><pre>%=</td><td><pre>op.assign.rem</pre></td></tr>
<tr><td><pre>&=</td><td><pre>op.assign.bitand</pre></td></tr>
<tr><td><pre>|=</td><td><pre>op.assign.bitor</pre></td></tr>
<tr><td><pre>^=</td><td><pre>op.assign.bitxor</pre></td></tr>

<tr><td colspan=2>Conditional Ternary</td></tr>
 

<tr><td><pre>? :</td><td><pre>op.ternary.qmark</pre></td></tr>

<tr><td colspan=2>Implication</td></tr>


<tr><td><pre>-></td><td><pre>op.binary.impl <sup>(*)</sup></pre></td></tr>

<tr><td colspan=2>Boolean OR</td></tr>


<tr><td><pre>|| or "or"</td><td><pre>op.binary.or</pre></td></tr>

<tr><td colspan=2>Boolean AND</td></tr>

<tr><td><pre>&& or "and"</td><td><pre>op.binary.and</pre></td></tr>

<tr><td colspan=2>Bitwise OR</td></tr>

<tr><td><pre>|</td><td><pre>op.binary.bitor</pre></td></tr>

<tr><td colspan=2>Bitwise XOR</td></tr>

<tr><td><pre>^</td><td><pre>op.binary.bitxor</pre></td></tr>

<tr><td colspan=2>Bitwise AND</td></tr>

<tr><td><pre>&</td><td><pre>op.binary.bitand</pre></td></tr>

<tr><td colspan=2>Equality </td></tr>

<tr><td><pre>==</td><td><pre>op.binary.eq</pre></td></tr>
<tr><td><pre>!=</td><td><pre>op.binary.ne</pre></td></tr>


<tr><td colspan=2>Relational</td></tr>

<tr><td><pre>&lt;</td><td><pre>op.binary.lt</pre></td></tr>
<tr><td><pre>&gt;</td><td><pre>op.binary.gt</pre></td></tr>
<tr><td><pre>&lt;=</td><td><pre>op.binary.le</pre></td></tr>
<tr><td><pre>&gt;=</td><td><pre>op.binary.ge</pre></td></tr>


<tr><td colspan=2>Bitwise Shift</td></tr>

<tr><td><pre>&lt;&lt;</td><td><pre>op.binary.lshift</pre></td></tr>
<tr><td><pre>&gt;&gt;</td><td><pre>op.binary.rshift</pre></td></tr>
<tr><td><pre>&gt;&gt;&gt;</td><td><pre>op.binary.rshiftu</pre></td></tr>

<tr><td colspan=2>Additive</td></tr>

<tr><td><pre>+</td><td><pre>op.binary.add</pre></td></tr>
<tr><td><pre>-</td><td><pre>op.binary.subtract</pre></td></tr>

<tr><td colspan=2>Multiplicative</td></tr>

<tr><td><pre>*</td><td><pre>op.binary.multiply</pre></td></tr>
<tr><td><pre>-</td><td><pre>op.binary.divide</pre></td></tr>
<tr><td><pre>%</td><td><pre>op.binary.rem</pre></td></tr>


<tr><td colspan=2>Power</td></tr>

<tr><td><pre>**</td><td><pre>op.binary.pow <sup>(*)</sup></pre></td></tr>

<tr><td colspan=2>Unary Operators</td></tr>

<tr><td><pre>+</td><td><pre>op.unary.positive</td></tr>
<tr><td><pre>-</td><td><pre>op.unary.negative</td></tr>
<tr><td><pre>++x</td><td><pre>op.prefix.inc</td></tr>
<tr><td><pre>--x</td><td><pre>op.prefix.dec</td></tr>
<tr><td><pre>x++</td><td><pre>op.suffix.inc</td></tr>
<tr><td><pre>x++</td><td><pre>op.suffix.dec</td></tr>
<tr><td><pre>!</td><td><pre>op.unary.not</td></tr>
<tr><td><pre>~</td><td><pre>op.unary.bitnot</td></tr>
<tr><td><pre>(cast)</td><td><pre>type.cast</td></tr>
<tr><td><pre>|x|</td><td><pre>op.unary.abs <sup>(*)</sup></td></tr>



<tr><td colspan=2><sup>(*)</sup> <b><i>Operators do not exist in Java Standard, only in org.openl.j, but yoo can use and 
overload them at will</i></b></td></tr>

</table>

